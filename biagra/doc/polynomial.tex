%
% polynomial.h
%

\chapter{Polynomial (polynomials.h)} \label{sec:polynomial}

\section{Introduction}

Functions to manage polynomials are defined in \texttt{polynomial.h} file.\\

Polynomials are stored using a \BI\ data structure named \texttt{biaRealPol}\footnote{Section \ref{sec:biaRealPol} in page \pageref{sec:biaRealPol}.}.

\section{Polynomial evaluation}

\subsection{\texttt{dblEvaluatePol} function}

This function evaluate a polynomial in a given point and returns it.\\

The definition of this function:
%
\begin{verbatim}
double dblEvaluatePol(biaRealPol *ptPol, double dblX);  
\end{verbatim}
%
where:
\begin{description} 
\item[*ptPol] pointer to a \texttt{biaRealPol} struct.
\item[dblX] point in which the polynomial has to be evaluated.
\end{description}
%
The \texttt{biaRealPol} has to be initialized with the polynomial degree and polynomial coeficients.

\note{See section \ref{sec:biaRealPol} to understand how \texttt{biaRealPol} is used.}

\section{Polynomial derivatives}

\subsection{\texttt{derivativePol} function}

This function gets the $n$-th derivative of a polynomial.\\

The definition of this function:
%
\begin{verbatim}
int derivativePol(biaPol *ptPol, biaPol *ptDer, int intN);
\end{verbatim}
%
where:
\begin{description} 
\item[*ptPol] pointer to a \texttt{biaRealPol} struct with the polynomial to get its derivative is stored.
\item[*ptDer] pointer to a \texttt{biaRealPol} struct where the derivative will be stored.
\item[intN] order of the derivative to get.
\end{description}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\end{tabular}
\end{center}
%
\note{\texttt{ptDer} will be released and memory allocation will be carried out to store the derivative.}
%
\warning{\texttt{ptDer} member \texttt{dblCoefs} has to be initialized to a \texttt{NULL} pointer to avoid a \textbf{Segment Fault} error if it was not previously initialized.}

\section{Arithmetical operations using polynomials}

\subsection{\texttt{addPol} function}

This function adds two polynomials.\\

The definition of this function:
%
\begin{verbatim}
int addPol(biaPol *ptPol1, biaPol *ptPol2, biaPol *ptRes);  
\end{verbatim}
%
where:
%
\begin{description}
\item[*ptPol1] pointer to a \texttt{biaPol} struct with the first polynomial to be added.
\item[*ptPol2] pointer to a \texttt{biaPol} struct with the second polynomial to be added.
\item[*ptRes] pointer to a \texttt{biaPol} struct where the add operation will be stored.
\end{description}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\end{tabular}
\end{center}
%
\note{\texttt{ptRes} will be released and memory allocation will be carried out to store the derivative.}
%
\warning{\texttt{ptRes} member \texttt{dblCoefs} has to be initialized to a \texttt{NULL} pointer to avoid a \textbf{Segment Fault} error if it was not previously initialized.}

\subsection{\texttt{subtractPol} function}

This function subtracts two polynomials.\\

The definition of this function:
%
\begin{verbatim}
int subtractPol(biaPol *ptPol1, biaPol *ptPol2, biaPol *ptRes);
\end{verbatim}
%
where:
%
\begin{description}
\item[*ptPol1] pointer to a \texttt{biaPol} struct with the first polynomial.
\item[*ptPol2] pointer to a \texttt{biaPol} struct with the polynomial to be subtracted from the above.
\item[*ptRes] pointer to a \texttt{biaPol} struct where the subtract operation will be stored.
\end{description}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\end{tabular}
\end{center}
%
\note{\texttt{ptRes} will be released and memory allocation will be carried out to store the derivative.}
%
\warning{\texttt{ptRes} member \texttt{dblCoefs} has to be initialized to a \texttt{NULL} pointer to avoid a \textbf{Segment Fault} error if it was not previously initialized.}

\subsection{\texttt{multiplyPol} function}

This functions multiplies two polynomials.\\

The definition of this function:
%
\begin{verbatim}
int subtractPol(biaPol *ptPol1, biaPol *ptPol2, biaPol *ptRes);
\end{verbatim}
%
where:
%
\begin{description}
\item[*ptPol1] pointer to a \texttt{biaPol} struct with the first polynomial.
\item[*ptPol2] pointer to a \texttt{biaPol} struct with the second polynomial.
\item[*ptRes] pointer to a \texttt{biaPol} struct where the multiplication operation will be stored.
\end{description}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\end{tabular}
\end{center}
%
\note{\texttt{ptRes} will be released and memory allocation will be carried out to store the derivative.}
%
\warning{\texttt{ptRes} member \texttt{dblCoefs} has to be initialized to a \texttt{NULL} pointer to avoid a \textbf{Segment Fault} error if it was not previously initialized.}

\section{Polynomial roots approximations}

\subsection{\texttt{newtonPol} function}

This function approaches a polynomial root using the \textbf{Newton} method.\\

The definition of this function:
%
\begin{verbatim}
int newtonPol(biaPol *ptPol, biaRealRoot *ptRoot);  
\end{verbatim}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_ZERO\_DIV} & Division by zero \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\textbf{BIA\_FALSE} & Root approximation could not be calculated \\
                    & satisfying the requirements (\texttt{intMNI} and \texttt{dblTol}). \\
\hline
\end{tabular}
\end{center}

\texttt{biaRealRoot *ptRoot} has to be initialized:
%
\begin{description}
\item[intMNI] maximun number of iterations.
\item[dblx0] initial approximation.
\item[dblTol] tolerance to approximate the root.
\end{description}
%
\note{When two consecutive approximations are close enough, \texttt{dblTol}, last approximation will be considered as good and will be stored in \texttt{*biaRealRoot *ptRoot} in \texttt{dblRoot}.}
%
\ \\ \\ \\
%
\note{In \texttt{intIte} will be stored the number of iterations used to get the root and in \texttt{dblError} will be stored the error between the two last approximations.}





