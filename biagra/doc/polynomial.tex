%
% polynomial.h
%

\chapter{Polynomial (polynomials.h)} \label{sec:polynomial}

\section{Introduction}

Functions to manage polynomials are defined in \texttt{polynomial.h} file.\\

A polynomial used to be represented as shown in equation \ref{equ:pol}.

\begin{equation} \label{equ:pol}
p(x) = a_0 + a_1 \cdot x + \cdots + a_n \cdot x^n = \sum_{i=0}^n a_i \cdot x^i \qquad \textrm{where } a_i \in \mathbb{R}
\end{equation}

\section{Data structures}

Some data structures are defined in \BI to manage polynomials.

\subsection{\texttt{biaRealPol} data structure} \label{sec:biaRealPol}

This data structure is used to handle polinomials $p(x) \in \mathbb{R}[x]$. \textbf{biaPol} data structure is defined in figure \ref{fig:biaRealPol} where:
%
\begin{description}
\item[intDegree] polynomial degree.
\item[intRealRoots] number of real roots (if any).
\item[intCompRoots] number of complex roots (if any).
\item[*dblCoef] pointer to store polynomial coeficients.
\end{description}
%
\begin{figure}[!h]
\begin{verbatim}
typedef struct {
  int  intDegree    = 0,
       intRealRoots = 0,
       intCompRoots = 0;

  double  *dblCoefs;
  } biaRealPol;
\end{verbatim}
\caption{biaRealPol data structure.} \label{fig:biaRealPol}
\end{figure}
%
\FloatBarrier
%
Polynomial coeficients are stored in \texttt{dblCoefs} pointer which has to be previously initialized:
%
\begin{eqnarray*}
  \mathrm{dblCoefs[0]} & = & a_0 \\
  \mathrm{dblCoefs[1]} & = & a_1 \\
  \dots & \dots & \dots \\
  \mathrm{dblCoefs[n]} & = & a_n \\
\end{eqnarray*}

\subsection{\texttt{biaRealRoot} data structure} \label{sec:biaRealRoot}

This data structure is used to store data for root approximation. Data structure is defined in figure \ref{fig:biaRealRoot} where:

\begin{description}
\item[intNMI] maximum number of iterations to get the root with a maximum error of \emph{dblTol}.
\item[intIte] iterations used to get the root.
\item[dblx0] initial approximation to get the root.
\item[dblRoot] root approximation.
\item[dblTol] maximum tolerance when calculating the root.
\item[dblError] error in root approximation. Difference between the las two root approximations.
\end{description}

\begin{figure}[!h]
\begin{verbatim}
typedef struct {
  int intNMI,
      intIte;

  double dblx0,
         dblRoot,
         dblTol,
         dblError;
  } biaRealRoot;
\end{verbatim}
\caption{biaRealRoot data structure.} \label{fig:biaRealRoot}
\end{figure}

\FloatBarrier

\section{Polynomial derivatives}

\subsection{\texttt{derivativePol} function}

This function gets the $n$-th derivative of a polynomial.\\ \\
%
The definition of this function:
%
\begin{verbatim}
int derivativePol(biaPol *ptPol, biaPol *ptDer, int intN);
\end{verbatim}
%
where:
\begin{description} 
\item[*ptPol] pointer to a \texttt{biaRealPol} struct with the polynomial to get its derivative is stored.
\item[*ptDer] pointer to a \texttt{biaRealPol} struct where the derivative will be stored.
\item[intN] order of the derivative to get.
\end{description}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\end{tabular}
\end{center}
%
\note{\texttt{ptDer} will be released and memory allocation will be carried out to store the derivative.}
%
\warning{\texttt{ptDer} member \texttt{dblCoefs} has to be initialized to a \texttt{NULL} pointer to avoid a \textbf{Segment Fault} error if it was not previously initialized.}

\section{Arithmetical operations using polynomials}

\subsection{\texttt{addPol} function}

This function adds two polynomials.\\ \\
%
The definition of this function:
%
\begin{verbatim}
int addPol(biaPol *ptPol1, biaPol *ptPol2, biaPol *ptRes);  
\end{verbatim}
%
where:
%
\begin{description}
\item[*ptPol1] pointer to a \texttt{biaPol} struct with the first polynomial to be added.
\item[*ptPol2] pointer to a \texttt{biaPol} struct with the second polynomial to be added.
\item[*ptRes] pointer to a \texttt{biaPol} struct where the add operation will be stored.
\end{description}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\end{tabular}
\end{center}
%
\note{\texttt{ptRes} will be released and memory allocation will be carried out to store the derivative.}
%
\warning{\texttt{ptRes} member \texttt{dblCoefs} has to be initialized to a \texttt{NULL} pointer to avoid a \textbf{Segment Fault} error if it was not previously initialized.}

\subsection{\texttt{subtractPol} function}

This function subtracts two polynomials.\\ \\
%
The definition of this function:
%
\begin{verbatim}
int subtractPol(biaPol *ptPol1, biaPol *ptPol2, biaPol *ptRes);
\end{verbatim}
%
where:
%
\begin{description}
\item[*ptPol1] pointer to a \texttt{biaPol} struct with the first polynomial.
\item[*ptPol2] pointer to a \texttt{biaPol} struct with the polynomial to be subtracted from the above.
\item[*ptRes] pointer to a \texttt{biaPol} struct where the subtract operation will be stored.
\end{description}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\end{tabular}
\end{center}
%
\note{\texttt{ptRes} will be released and memory allocation will be carried out to store the derivative.}
%
\warning{\texttt{ptRes} member \texttt{dblCoefs} has to be initialized to a \texttt{NULL} pointer to avoid a \textbf{Segment Fault} error if it was not previously initialized.}

\subsection{\texttt{multiplyPol} function}

This functions multiplies two polynomials.\\ \\
%
The definition of this function:
%
\begin{verbatim}
int subtractPol(biaPol *ptPol1, biaPol *ptPol2, biaPol *ptRes);
\end{verbatim}
%
where:
%
\begin{description}
\item[*ptPol1] pointer to a \texttt{biaPol} struct with the first polynomial.
\item[*ptPol2] pointer to a \texttt{biaPol} struct with the second polynomial.
\item[*ptRes] pointer to a \texttt{biaPol} struct where the multiplication operation will be stored.
\end{description}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\end{tabular}
\end{center}
%
\note{\texttt{ptRes} will be released and memory allocation will be carried out to store the derivative.}
%
\warning{\texttt{ptRes} member \texttt{dblCoefs} has to be initialized to a \texttt{NULL} pointer to avoid a \textbf{Segment Fault} error if it was not previously initialized.}

\section{Polynomial root approximations}

\subsection{\texttt{newtonPol} function}

This function approaches a polynomial root using the \textbf{Newton} method.\\ \\
%
The definition of this function:
%
\begin{verbatim}
int newtonPol(biaPol *ptPol, biaRealRoot *ptRoot);  
\end{verbatim}
%
The following codes are returned:
%
\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{BIA\_MEM\_ALLOC} & Memory allocation error \\
\hline
\textbf{BIA\_ZERO\_DIV} & Division by zero \\
\hline
\textbf{BIA\_TRUE} & Success \\
\hline
\textbf{BIA\_FALSE} & Root approximation could not be calculated \\
                    & satisfying the requirements (\texttt{intMNI} and \texttt{dblTol}). \\
\hline
\end{tabular}
\end{center}

\texttt{biaRealRoot *ptRoot} has to be initialized:
%
\begin{description}
\item[intMNI] maximun number of iterations.
\item[dblx0] initial approximation.
\item[dblTol] tolerance to approximate the root.
\end{description}
%
\note{When two consecutive approximations are close enough, \texttt{dblTol}, last approximation will be considered as good and will be stored in \texttt{*biaRealRoot *ptRoot} in \texttt{dblRoot}.}
%
\ \\ \\ \\
%
\note{In \texttt{intIte} will be stored the number of iterations used to get the root and in \texttt{dblError} will be stored the error between the two last approximations.}





