\chapter{?`Como utilizar \BI?}

En este cap\'{\i}tulo vamos a explicar algunas generalidades de esta 
biblioteca, aunque he intentado explicar e ilustrar cada funci\'on lo mejor
posible, es posible que no todo este claro o se me haya olvidado algo.\\

\section{Recomendaciones}

\begin{itemize}
\item Leerse bien la documentaci\'on que acompa\~na a la biblioteca.
\item Estar familiarizado con el lenguaje \textbf{C}.
\item Estar familiarizado con los \textbf{m\'etodos num\'ericos} y 
\textbf{matem\'aticas} en general.
\item Estar familiarizado con los \textbf{tipos de datos definidos por el
usuario}.
\item Estar familiarizado con el uso de \textbf{punteros}.
\item Estar familiarizado con la \textbf{Ley de Murphy}. \textbf{;-)}
\end{itemize}

\section{Ideas generales}

Estas son algunas de las ideas utilizadas por \BI.

\newpage

\subsection{Tipos de datos definidos por el usuario}

En ciertos m\'etodos num\'ericos se necesitan muchos datos, el llamar a una
funci\'on a la que hay que pasarle muchos par\'ametros es un incordio y estamos
espuestos a los tipicos errores:

\begin{enumerate}
\item Olvidarnos alg\'un par\'ametro.
\item Pasar alg\'un par\'ametro incorrecto.
\item Pasar par\'ametros en orden indebido.
\end{enumerate}

Esto lo solucionamos con los tipos de datos definidos por el usuario, donde
agrupamos todos los datos que necesita un m\'etodo num\'erico en una estructura
y en lugar de pasar una lista interminable de par\'ametros a una funci\'on 
s\'olo pasamos uno, que es la estructura que recoge todos esos datos.\newline

Pero tambi\'en hemos de tener cuidado con inicializar debidamente los miembros
de la estructura antes de empezar a operar con ella, los necesarios,
ya que si se nos olvida inicializar alg\'un miembro podemos obtener resultados
incoherentes, por ejemplo en una estructura que contiene polinomios\footnote{%
Apartado (\ref{sec:strPolinomio}) en la p\'agina \pageref{sec:strPolinomio}.}
si inicializamos los coeficientes del polinomio y no inicializamos el miembro
que contiene el grado del polinomio las operaciones que realizemos con ese
polinomio no ser\'an correctas, pues todas las funciones de la biblioteca que
manejan polinomios consideran como grado de dicho polinomio al grado que le
dice dicha estructura.\\

No es necesario inicializar todos los miembros de una estructura. Por ejemplo
en la estructura anterior los miembros \emph{intNumReal} y \emph{intNumComp}
se utilizan para almacenar el n\'umero de raices reales y complejas del 
polinomio, estos datos es muy posible que no los sepamos y para poder saberlos
necesitariamos utilizar alg\'un m\'etodo, luego no es necesario inicilizar
estos miembros, salvo que utilizemos alguna funci\'on que ``s\'{\i}'' que 
necesite utilizar estos datos. En este caso habr\'{\i}a que calcularlos de
``alguna'' forma.

\subsection{Punteros}

El uso de punteros es debido a que se busca el poder resolver diferentes
tipos de problemas sin modificar el c\'odigo de la biblioteca.\newline

Por ejemplo, escribir una funci\'on que calcule la inversa de una matriz,
no importa de que orden sea\footnote{No es muy buen ejemplo, pero bueno.}.\\

Mediante el uso de punteros podemos coger o liberar memoria en tiempo de 
ejecuci\'on seg\'un sean nuestras necesidades\footnote{Y las
caracter\'{\i}sticas de nuestro equipo.} esto es imposible de hacer con los
\emph{arrays}, ya que la dimensi\'on de un \emph{array} ha de ser especificada
en tiempo de compilaci\'on y no puede ser variada en tiempo de ejecuci\'on.\\

El uso de punteros en \textbf{C} es muy potente, pero a la vez es extremadamente
peligroso, ya que \textbf{C} no realiza comprobaci\'on de indices. Si estas
familiarizado con los \emph{arrays} sabras\footnote{O deber\'{\i}as saber.} que
si hemos declarado un \emph{array} con $n$ elementos es posible acceder al
elemento $n+5$ o al elemento $-3$ del \emph{array}, como es obvio estos
elementos no forman parte de nuestro \emph{array} y si modificamos su contenido
s\'olo ``Dios'' sabe ``donde'' estamos escribiendo, con lo que es posible 
modificar otros datos o parte de las instrucciones de nuestro programa, o
incluso de otros programas que en ese momento esten en memoria. Con el uso
de punteros para reservas de memoria pasa lo mismo, si hemos reservado memoria
para $n$ elementos podemos acceder al dato $n+5$ o al $-3$ de nuestro puntero y
\dots \newline

Aquellos que no estan familiarizados con este lenguaje este tipo de cosas les
parecen incongruencias o fallos al dise\~nar el lenguaje, pero no esto no es
as\'{\i} ya que cosas como esta permiten al programador una flexibilidad y
potencia fuera del alcance de muchos lenguajes, con el peligro que esto 
entra\~na, pero como nada es perfecto todo tiene su lado positivo y su lado
negativo, asi que mucho cuidado con los punteros.\newline

Por lo que hemos dicho antes hay que inicializar bien los miembros de las
estructuras de \BI que nos indican la dimensi\'on de los punteros en ellas
contenidas. Algunas funciones, sobre todo las que operan con dos datos del
mismo tipo y almacenan el resultado en otro, para evitar fallos del programador
dimensionan ellas mismas la variable en la que se va a almacenar el resultado,
por lo que si el puntero contenido en esa variable \textbf{NO ha sido
dimensionado previamente hay que inicializarlo a $0$}, en caso contrario nos
encontrar\'{\i}amos con un error del tipo \textbf{Segment Fault} en tiempo de
ejecuci\'on. De todas formas consulta la informaci\'on de las funciones de
\BI antes de utilizarlas ya que estos casos estan detallados.
