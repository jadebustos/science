%
% RNGKUTTA.H
%

\chapter{Runge-Kutta methods (rngkutta.h)}

\section{Introduction}

\textbf{Runge-Kutta} are a family of implicit and explicit iterative methods used to approximate solutions of ordinary differential equations or \textbf{ODE}.\\

Butcher matricial notation is used in this implementation.\\

\section{Data structures}

\subsection{\texttt{biaButcherArray} data structure}

This structure is used to store the Butcher matricial notation.\\

Data structure is defined in figure \ref{fig:biaButcherArray} where:
%
\begin{description}
%
\item[intStages] method stages.
%
\item[*dblC] $c_i$ coefficients stored in an array with size \texttt{intStages}.
%
\item[*dblB] $b_i$ coefficients stored in an array with size \texttt{intStages}.
%
\item[**dblMatrix] matrix to store $a_{i,j}$ method's coeficients.  
%
\end{description}

\begin{figure}[!h]
\begin{verbatim}
typedef struct {
  double  *dblC,
          *dblB,
          **dblMatrix;

  int     intStages;
} biaButcherArray;
\end{verbatim}
\caption{biaButcherArray data structure.} \label{fig:biaButcherArray}
\end{figure}
%
\FloatBarrier

\subsection{\texttt{DataRK} data structure}

This structure is used to store all the data needed to apply a Runge-Kutta method.\\

Data structure is defined in figure \ref{fig:biaDataRK} where:
%
\begin{description}
%
\item[intNumApprox] number of approximations to be done (size of the array \texttt{dblPoints}).
%
\item[intImplicit] when the Runge-Kutta method is implicit or not. The following constants are defined in the header file:
%
  \begin{center}
  \begin{tabular}{|c|c|}
    \hline
    \textbf{Name} & \textbf{Value} \\
    \hline
    \textbf{BIA\_IMPLICIT\_RK\_TRUE} & $0$ \\
    \hline
    \textbf{BIA\_IMPLICIT\_RK\_FALSE} & $1$ \\
    \hline
  \end{tabular}
  \end{center}  
%
\item[*dblPoints]
%
\item[dblStepSize]
%
\end{description}

\begin{figure}[!h]
\begin{verbatim}
typedef struct {
  int intNumApprox,
      intImplicit;

  double  *dblPoints,
          dblStepSize,
          dblFirst,
          dblLast;

  biaButcherArray strCoefs;
} biaDataRK;
\end{verbatim}
\caption{biaDataRK data structure.} \label{fig:biaDataRK}
\end{figure}
%
\FloatBarrier

\section{Explicit Runge-Kutta methods}

Let's assume that the initial value problem (I.V.P.) or Cauchy problem we want to solve is:
%
\begin{eqnarray*}
  y'(x) & = & f(x, y(x)) \\
  y(x_0) & = & y_0
\end{eqnarray*}
%
The family of explicit \textbf{Runge-Kutta} methods is given by:
%
\begin{displaymath}
  y_{n+1} = y_n  + h \cdot \sum_{i=1}^s b_i \cdot k_i
\end{displaymath}
%
where:
%
\begin{eqnarray*}
  k_i & = & f(x_n + (h\cdot c_i), y_n + h\cdot \left(\sum_{j=1}^{i-1} a_{i,j} \cdot k_j \right) )\\
  c_i & = & \sum_{j=1}^{i-1} a_{i,j} \qquad \textrm{where} \qquad i \in \{2,\dots,s\}
\end{eqnarray*}

\subsection{\texttt{ExplicitRungeKutta} function}

\subsection{\texttt{RungeKuttaClasico} function}

Funci\'on que inicializa los coeficientes para el m\'etodo \emph{Runge-Kutta 
Cl\'asico}, el cual es un m\'etodo de $4$ etapas y orden $4$.\newline

La notaci\'on matricial del m\'etodo es la siguiente:

\begin{center}
$
\begin{array}{c|cccc}
0 & 0 \\
\frac{1}{2} & \frac{1}{2} & 0 \\
\frac{1}{2} & 0 & \frac{1}{2} & 0 \\
1 & 0 & 0 & 1 & 0 \\
\hline
 & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6} \\
\end{array}
$
\end{center}

El prototipo de esta funci\'on es el siguiente:

\begin{center}
\emph{int \textbf{RungeKuttaClasico}(DatosRK *ptstrDatos)}
\end{center}

\begin{description}
\item[ptstrDatos] puntero a una variable de \emph{estructura} del tipo
\emph{DatosRK}.
\end{description}

La funci\'on devuelve los siguientes c\'odigos:

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{ERR\_AMEM} & Hubo un error en la asignaci\'on de memoria. \\
\hline
\textbf{TRUE} & Se inicializaron con \'exito los coeficientes. \\
\hline
\end{tabular}
\end{center}

Por ejemplo:

\begin{center}
\emph{intResultado = \textbf{RungeKuttaClasico}(\&varstrDatRK);}
\end{center}

Inicializar\'{\i}a los coeficientes del m\'etodo en la variable 
\emph{varstrDatRK}, en \emph{intResultado} el valor \textbf{TRUE} si se pudieron
inicializar los coeficientes y en caso contrario \textbf{ERR\_AMEM}.

\subsection{MetodoHeun}
Funci\'on que inicializa los coeficientes para el m\'etodo de \emph{Heun}, el
cual es un m\'etodo \emph{Runge-Kutta} de $3$ etapas y orden $3$.\newline

La notaci\'on matricial del m\'etodo es la siguiente:

\begin{center}
$
\begin{array}{c|ccc}
0 & 0 \\
\frac{1}{3} & \frac{1}{3} & 0 \\
\frac{2}{3} & 0 & \frac{2}{3} & 0 \\
\hline
 & \frac{1}{4} & 0 & \frac{3}{4}
\end{array}
$
\end{center}

El prototipo de esta funci\'on es el siguiente:

\begin{center}
\emph{int \textbf{MetodoHeun}(DatosRK *ptstrDatos)}
\end{center}

\begin{description}
\item[ptstrDatos] puntero a una variable de \emph{estructura} del tipo
\emph{DatosRK}.
\end{description}

La funci\'on devuelve los siguientes c\'odigos:

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{ERR\_AMEM} & Hubo un error en la asignaci\'on de memoria. \\
\hline
\textbf{TRUE} & Se inicializaron con \'exito los coeficientes. \\
\hline
\end{tabular}
\end{center}

Por ejemplo:

\begin{center}
\emph{intResultados = \textbf{MetodoHeun}(\&varstrDatRK);}
\end{center}

Inicializar\'{\i}a los coeficientes del m\'etodo en la variable
\emph{varstrDatRK}, en \emph{intResultado} el valor \textbf{TRUE} si se pudieron
inicializar los coeficientes y en caso contrario \textbf{ERR\_AMEM}.

\subsection{MetodoKutta}

Funci\'on que inicializa los coeficientes para el m\'etodo de \emph{Kutta}, el
cual es un m\'etodo \emph{Runge-Kutta} de $3$ etapas y orden $3$.\newline

La notaci\'on matricial del m\'etodo es la siguiente:

\begin{center}
$
\begin{array}{c|ccc}
0 & 0 \\
\frac{1}{2} & \frac{1}{2} & 0 \\
1 & -1 & 2 & 0 \\
\hline
 & \frac{1}{6} & \frac{2}{3} & \frac{1}{6}
\end{array}
$
\end{center}

El prototipo de esta funci\'on es el siguiente:

\begin{center}
\emph{int \textbf{MetodoKutta}(DatosRK *ptstrDatos)}
\end{center}

\begin{description}
\item[ptstrDatos] puntero a una variable de \emph{estructura} del tipo
\emph{DatosRK}.
\end{description}

La funci\'on devuelve los siguientes c\'odigos:

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{ERR\_AMEM} & Hubo un error en la asignaci\'on de memoria. \\
\hline
\textbf{TRUE} & Se inicializaron con \'exito los coeficientes. \\
\hline
\end{tabular}
\end{center}

Por ejemplo:

\begin{center}
\emph{intResultado = \textbf{MetodoKutta}(\&varstrDatRK);}
\end{center}

Inicializar\'{\i}a los coeficientes del m\'etodo en la variable
\emph{varstrDatRK}, en \emph{intResultado} el valor \textbf{TRUE} si se pudieron
inicializar los coeficientes y en caso contrario \textbf{ERR\_AMEM}.

\subsection{\texttt{EulerModificado} function}

Funci\'on que inicializa los coeficientes para el m\'etodo de \emph{Euler 
modificado}, el cual es un m\'etodo \emph{Runge-Kutta} de $2$ etapas y 
orden $2$.\newline

La notaci\'on matricial del m\'etodo es la siguiente:

\begin{center}
$
\begin{array}{c|cc}
0 & 0 \\
\frac{1}{2} & \frac{1}{2} & 0 \\
\hline
 & 0 & 1
\end{array}
$
\end{center}

El prototipo de esta funci\'on es el siguiente:

\begin{center}
\emph{int \textbf{EulerModificado}(DatosRK *ptstrDatos)}
\end{center}

\begin{description}
\item[ptstrDatos] puntero a una variable de \emph{estructura} del tipo
\emph{DatosRK}.
\end{description}

La funci\'on devuelve los siguientes c\'odigos:

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{ERR\_AMEM} & Hubo un error en la asignaci\'on de memoria. \\
\hline
\textbf{TRUE} & Se inicializaron con \'exito los coeficientes. \\
\hline
\end{tabular}
\end{center}

Por ejemplo:

\begin{center}
\emph{intResultado = \textbf{EulerModificado}(\&varstrDatRK);}
\end{center}


Inicializar\'{\i}a los coeficientes del m\'etodo en la variable
\emph{varstrDatRK}, en \emph{intResultado} el valor \textbf{TRUE} si se pudieron
inicializar los coeficientes y en caso contrario \textbf{ERR\_AMEM}.

\subsection{\texttt{EulerMejorado} function}

Funci\'on que inicializa los coeficientes para el m\'etodo de \emph{Euler mejorado},
el cual es un m\'etodo \emph{Runge-Kutta} de $2$ etapas y orden $2$.\newline

La notaci\'on matricial del m\'etodo es la siguiente:

\begin{center}
$
\begin{array}{c|cc}
0 & 0 \\
1 & 1 & 0 \\
\hline
 & \frac{1}{2} & \frac{1}{2}
\end{array}
$
\end{center}

El prototipo de esta funci\'on es el siguiente:

\begin{center}
\emph{int \textbf{EulerMejorado}(DatosRK *ptstrDatos)}
\end{center}

\begin{description}
\item[ptstrDatos] puntero a una variable de \emph{estructura} del tipo
\emph{DatosRK}.
\end{description}

La funci\'on devuelve los siguientes c\'odigos:

\begin{center}
\begin{tabular}{|l|l|}
\hline
\textbf{ERR\_AMEM} & Hubo un error en la asignaci\'on de memoria. \\
\hline
\textbf{TRUE} & Se inicializaron con \'exito los coeficientes. \\
\hline
\end{tabular}
\end{center}

Por ejemplo:

\begin{center}
\emph{intResultado = \textbf{EulerMejorado}(\&varstrDatRK);}
\end{center}


Inicializar\'{\i}a los coeficientes del m\'etodo en la variable
\emph{varstrDatRK}, en \emph{intResultado} el valor \textbf{TRUE} si se pudieron
inicializar los coeficientes y en caso contrario \textbf{ERR\_AMEM}.





Todas estas funciones suponen que la variable de \emph{estructura}, del tipo
\emph{DatosRK}\footnote{Apartado (\ref{sec:datosRK}) en la p\'agina 
\pageref{sec:datosRK}}, no tienen dimensionados los punteros en ella 
contenidos, raz\'on por la cual ser\'a necesario liberar la memoria asignada
a estos antes de pasarle como parametro una variable de este tipo a una de
las siguientes funciones(siempre y cuando se hayan dimensionado dichos
punteros).\newline

Hay que destacar que \textbf{NO} se inicializan todos los miembros de esta
estructura, s\'olo aquellos miembros que contienen los coeficientes del 
m\'etodo.\newline

Los siguientes miembros \textbf{NO} se inicializan:
%
\begin{description}
\item[intNumAprox]
\item[dblPuntos]
\item[dblPaso]
\item[dblInicio]
\item[dblFinal]
\end{description}

Estos miembros son independientes del m\'etodo, dependen del problema que
se quiera resolver y tendr\'an que ser inicializados por el usuario.
