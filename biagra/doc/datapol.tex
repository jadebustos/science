%
% datapol.h
%

\chapter{Polynomial data structures (datapol.h)}

\section{Introduction}

Data structures for polynomials are defined in \texttt{datapol.h} file.\\

A polynomial used to be represented as shown in equation \ref{equ:pol}.

\begin{equation} \label{equ:pol}
p(x) = a_0 + a_1 \cdot x + \cdots + a_n \cdot x^n = \sum_{i=0}^n a_i \cdot x^i \qquad \textrm{where } a_i \in \mathbb{R}
\end{equation}

\section{\textbf{biaRealPol} data structure} \label{sec:biaRealPol}

This data structure is used to handle polinomials $p(x) \in \mathbb{R}[x]$. \textbf{biaPol} data structure is defined in figure \ref{fig:biaRealPol} where:

\begin{description}
\item[intDegree] polynomial degree.
\item[intRealRoots] number of real roots (if any).
\item[intCompRoots] number of complex roots (if any).
\item[*dblCoef] pointer to store polynomial coeficients.
\end{description}

\begin{figure}[!h]
\begin{verbatim}
typedef struct {
  int  intDegree    = 0,
       intRealRoots = 0,
       intCompRoots = 0;

  double  *dblCoefs;
  } biaRealPol;
\end{verbatim}
\caption{biaRealPol data structure.} \label{fig:biaRealPol}
\end{figure}

\FloatBarrier

\subsection{How to use it}

%
\begin{verbatim}
#include <stdlib.h>
#include <datapol.h>

int main(void) {

  /* var declaration */
  biaRealPol myPol;
  ...
  /* polynomial degree */
  myPol.intDegree = 3;  
  ...
  /* memory allocation */
  myPol.dblCoefs = (double *)calloc(myPol.intDegree + 1, sizeof(double));  
  ...
  /* store coeficients */
  myPol.dblCoefs[0] = a0;
  myPol.dblCoefs[1] = a1;
  myPol.dblCoefs[2] = a2;
  ...
  myPol.dblCoefs[n] = an;
  /* your stuff here */
  ...
  return 0;
}
\end{verbatim}

\note{Bare in mind that a $n$ degree polynomial has $n+1$ coeficients.}

\tip{In examples directory \texttt{datapol-biaRealPol.c} shows a simple way to use it.}

\section{\textbf{biaRealRoot} data structure} \label{sec:biaRealRoot}

This data structure is used to store data for root approximation. Data structure is defined in figure \ref{fig:biaRealRoot} where:

\begin{description}
\item[intNMI] maximum number of iterations to get the root with a maximum error of \emph{dblTol}.
\item[intIte] iterations used to get the root.
\item[dblx0] initial approximation to get the root.
\item[dblRoot] root approximation.
\item[dblTol] maximum tolerance when calculating the root.
\item[dblError] error in root approximation. Difference between the las two root approximations.
\end{description}

\begin{figure}[!h]
\begin{verbatim}
typedef struct {
  int intNMI,
      intIte;

  double dblx0,
         dblRoot,
         dblTol,
         dblError;
  } biaRealRoot;
\end{verbatim}
\caption{biaRealRoot data structure.} \label{fig:biaRealRoot}
\end{figure}

\FloatBarrier

\subsection{How to use it}
